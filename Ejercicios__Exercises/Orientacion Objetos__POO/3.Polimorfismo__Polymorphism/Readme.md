# <a href="https://skillicons.dev"><img src="https://skillicons.dev/icons?i=cpp&perline=15" /></a> Polimorfismo / Polymorphism

---

## üéØ ¬øQu√© es el Polimorfismo? / What is Polymorphism?

El **polimorfismo** (del griego "poli" - muchas, y "morfe" - formas) es uno de los pilares fundamentales de la Programaci√≥n Orientada a Objetos (POO) en C++. Se refiere a la capacidad de un objeto de adoptar **m√∫ltiples formas**, permitiendo que diferentes clases respondan al mismo mensaje de maneras distintas.

En esencia, el polimorfismo nos permite tratar objetos de clases diferentes como si fueran del mismo tipo base, pero cada uno ejecutando su propio comportamiento espec√≠fico. Esto promueve la flexibilidad, la extensibilidad y la mantenibilidad del c√≥digo.

---

### Definici√≥n Formal / Formal Definition

El polimorfismo es la capacidad de un objeto de tomar m√∫ltiples formas, lo que permite que distintas clases respondan al mismo mensaje de diferentes maneras. Esta caracter√≠stica permite que objetos de diferentes clases sean tratados como si pertenecieran a una clase com√∫n y que cada uno exhiba su comportamiento espec√≠fico.

_Polymorphism is the ability of an object to take on multiple forms, allowing different classes to respond to the same message in distinct ways. Objects from different classes can be treated as members of a common base class and display individualized behavior._

---

## üöÄ Tipos de Polimorfismo en C++ / Types of Polymorphism in C++

En C++, el polimorfismo se manifiesta principalmente de dos formas:

1.  **Polimorfismo en Tiempo de Compilaci√≥n (Static Polymorphism):** Se resuelve durante la compilaci√≥n del programa. Ejemplos incluyen la **sobrecarga de funciones** y la **sobrecarga de operadores**.
    - _Resolved during program compilation. Examples include **function overloading** and **operator overloading**._
2.  **Polimorfismo en Tiempo de Ejecuci√≥n (Dynamic Polymorphism):** Se resuelve durante la ejecuci√≥n del programa, utilizando punteros o referencias a la clase base. Las **funciones virtuales** y las **clases abstractas** son la clave aqu√≠.
    - _Resolved during program execution, using base class pointers or references. **Virtual functions** and **abstract classes** are key here._

---

## ‚ú® Polimorfismo en Tiempo de Ejecuci√≥n: Funciones Virtuales / Runtime Polymorphism: Virtual Functions

Las **funciones virtuales** son el coraz√≥n del polimorfismo en tiempo de ejecuci√≥n en C++.

### ¬øC√≥mo funcionan? / How do they work?

- La palabra clave `virtual` en una funci√≥n dentro de una **clase base** le indica al compilador que esa funci√≥n puede ser sobrescrita (reimplementada) por las clases derivadas.
  - _The `virtual` keyword in a function within a **base class** tells the compiler that this function can be overridden (reimplemented) by derived classes._
- Cuando se llama a una funci√≥n virtual a trav√©s de un **puntero o una referencia de la clase base** que realmente apunta a un objeto de una clase derivada, C++ determina la implementaci√≥n correcta de la funci√≥n bas√°ndose en el **tipo real del objeto en tiempo de ejecuci√≥n**, no en el tipo del puntero o referencia. Esto se conoce como **despacho din√°mico** o **late binding**.
  - _When a virtual function is called through a **base class pointer or reference** that actually points to a derived class object, C++ determines the correct function implementation based on the **actual type of the object at runtime**, not the pointer or reference type. This is known as **dynamic dispatch** or **late binding**._

> üîÅ En tiempo de ejecuci√≥n, C++ determina la implementaci√≥n correcta de la funci√≥n con base en el **tipo real del objeto al que apunta el puntero o referencia**, no en el tipo declarado del puntero o referencia. Esto es lo que permite el comportamiento polim√≥rfico.
>
> _üîÅ At runtime, C++ determines the correct function implementation based on the **actual type of the object pointed to by the pointer or reference**, not the declared type of the pointer or reference. This is what enables polymorphic behavior._

---

## üîÑ Polimorfismo en Tiempo de Compilaci√≥n: Sobrecarga de Operadores / Compile-Time Polymorphism: Operator Overloading

La **sobrecarga de operadores** es una forma de polimorfismo que se resuelve en tiempo de compilaci√≥n. Permite redefinir c√≥mo los operadores (como `+`, `-`, `*`, `/`, etc.) act√∫an sobre objetos de tus propias clases.

- **Operator overloading** is a form of polymorphism resolved at compile-time. It allows you to redefine how operators (like `+`, `-`, `*`, `/`, etc.) behave when applied to objects of your own classes.\*

### ¬øC√≥mo funciona? / How does it work?

El compilador decide qu√© versi√≥n del operador utilizar bas√°ndose en los **tipos de los operandos** en tiempo de compilaci√≥n. No hay despacho din√°mico involucrado.

_The compiler decides which version of the operator to use based on the **types of the operands** at compile-time. No dynamic dispatch is involved._

> üß© Este tipo de polimorfismo ocurre en **tiempo de compilaci√≥n**. El compilador sabe exactamente qu√© funci√≥n de operador debe llamar bas√°ndose en los tipos de los operandos.
>
> _üß© This type of polymorphism occurs at **compile-time**. The compiler knows exactly which operator function to call based on the types of the operands._

---

## üö´ Clases Abstractas y Funciones Virtuales Puras / Abstract Classes and Pure Virtual Functions

Las **clases abstractas** son la base para definir interfaces en el polimorfismo de tiempo de ejecuci√≥n.

- **Abstract classes** are the foundation for defining interfaces in runtime polymorphism.\*

### Caracter√≠sticas / Characteristics

- Una clase se convierte en abstracta si contiene al menos una **funci√≥n virtual pura**.
  - _A class becomes abstract if it contains at least one **pure virtual function**._
- Una funci√≥n virtual pura se declara con `= 0;` al final de su firma en la clase base. Esto significa que la clase base **no proporciona una implementaci√≥n** para esa funci√≥n; en su lugar, **obliga a las clases derivadas a implementarla**.
  - _A pure virtual function is declared with `= 0;` at the end of its signature in the base class. This means the base class **does not provide an implementation** for that function; instead, it **forces derived classes to implement it**._
- **No se pueden crear instancias (objetos) de una clase abstracta directamente.** Solo pueden ser utilizadas como clases base para la herencia.
  - _You **cannot create instances (objects) of an abstract class directly**. They can only be used as base classes for inheritance._

> ‚ùì **¬øQu√© ocurre si intentas crear una instancia de una clase abstracta en C++?**
>
> \*‚ùì **What happens if you try to create an instance of an abstract class in C++?\***
>
> **Respuesta:** El compilador generar√° un **error de compilaci√≥n**, impidiendo la creaci√≥n del ejecutable. Las clases abstractas solo existen para servir como plantillas para otras clases, definiendo una interfaz com√∫n.
>
> - **Answer:** The compiler will generate a **compilation error**, preventing the executable from being created. Abstract classes only exist to serve as templates for other classes, defining a common interface.\*

---

## ‚úÖ La Palabra Clave `override` en Funciones Virtuales / The `override` Keyword in Virtual Functions

La palabra clave `override` (introducida en C++11) es un especificador que se usa al sobrescribir una funci√≥n virtual en una clase derivada.

_The `override` keyword (introduced in C++11) is a specifier used when overriding a virtual function in a derived class._

### Ventajas de usar `override` / Advantages of using `override`

- **Claridad:** Indica expl√≠citamente que la funci√≥n est√° sobrescribiendo una funci√≥n virtual de la clase base.
  - - **Clarity:** It explicitly indicates that the function is overriding a virtual function from the base class.\*
- **Seguridad:** El compilador verifica que la funci√≥n base realmente exista con la misma firma (nombre, tipo de retorno y par√°metros). Si la firma no coincide, el compilador generar√° un error, ayudando a prevenir errores comunes como typos o cambios en la funci√≥n base que no se reflejan en las derivadas.
  - - **Safety:** The compiler checks that the base function actually exists with the same signature (name, return type, and parameters). If the signature does not match, the compiler will generate an error, helping to prevent common mistakes like typos or changes in the base function not being reflected in derived ones.\*

> ‚úÖ Sobrescribir (`override`) un m√©todo significa **implementar una versi√≥n espec√≠fica** de una funci√≥n virtual definida en la clase base. Esto permite que las clases derivadas personalicen su comportamiento, manteniendo el contrato definido por la clase base.
>
> _‚úÖ Overriding (`override`) a method means **implementing a specific version** of a virtual function defined in the base class. This allows derived classes to customize their behavior while maintaining the contract defined by the base class._

---

## üí° Ventajas del Polimorfismo / Benefits of Polymorphism

El polimorfismo es una herramienta muy poderosa en POO por varias razones:

_Polymorphism is a very powerful tool in OOP for several reasons:_

1.  **Flexibilidad y Extensibilidad:** Permite a√±adir nuevas clases derivadas sin tener que modificar el c√≥digo existente que utiliza la clase base. Simplemente implementas la interfaz definida por la clase base.
    - - **Flexibility and Extensibility:** It allows you to add new derived classes without having to modify existing code that uses the base class. You simply implement the interface defined by the base class.\*
2.  **Mantenibilidad:** El c√≥digo se vuelve m√°s modular y f√°cil de mantener, ya que los cambios en la implementaci√≥n de una clase derivada no afectan a las otras.
    - - **Maintainability:** The code becomes more modular and easier to maintain, as changes in one derived class's implementation do not affect others.\*
3.  **Abstracci√≥n:** Puedes interactuar con diferentes tipos de objetos a trav√©s de una **interfaz com√∫n** (la de la clase base), lo que simplifica el dise√±o y la comprensi√≥n del sistema.
    - - **Abstraction:** You can interact with different types of objects through a **common interface** (that of the base class), which simplifies system design and understanding.\*
4.  **Reutilizaci√≥n de C√≥digo:** Al definir comportamientos gen√©ricos en la clase base, evitas duplicar c√≥digo en las clases derivadas.
    - - **Code Reusability:** By defining generic behaviors in the base class, you avoid duplicating code in derived classes.\*

> La principal ventaja del polimorfismo es que mejora dr√°sticamente la **flexibilidad, extensibilidad y mantenibilidad** del c√≥digo. Puedes interactuar con distintos tipos de objetos a trav√©s de una **interfaz com√∫n**, lo que facilita agregar nuevas funcionalidades sin modificar el c√≥digo existente.
>
> _The main advantage of polymorphism is that it drastically improves **code flexibility, extensibility, and maintainability**. You can interact with different types of objects through a **common interface**, making it easier to add new functionalities without modifying existing code._

---

## ‚ö†Ô∏è El Crucial Destructor Virtual / The Crucial Virtual Destructor

Cuando se trabaja con polimorfismo y memoria din√°mica (usando `new` y `delete`), es **absolutamente fundamental** que las clases base tengan un **destructor virtual**.

_When working with polymorphism and dynamic memory (using `new` and `delete`), it is **absolutely fundamental** that base classes have a **virtual destructor**._

### ¬øPor qu√© es importante? / Why is it important?

- Si eliminas un objeto de una clase derivada a trav√©s de un puntero a la clase base y el destructor de la clase base **no es virtual**, solo se llamar√° al destructor de la clase base. Los destructores de las clases derivadas no se ejecutar√°n.
  - _If you delete a derived class object through a base class pointer and the base class destructor is **not virtual**, only the base class destructor will be called. The destructors of the derived classes will not be executed._
- Esto puede llevar a **fugas de memoria** (memory leaks) si las clases derivadas asignan recursos que deben ser liberados en sus destructores, y a **comportamientos indefinidos**.
  - _This can lead to **memory leaks** if derived classes allocate resources that need to be released in their destructors, and to **undefined behavior**._

> üéØ Siempre usa **destructores virtuales en clases base** si se espera que estas clases sean heredadas y que los objetos derivados sean eliminados a trav√©s de punteros de la clase base. ¬°Esto te evitar√° muchos problemas de fugas de memoria y comportamientos inesperados\!
>
> _üéØ Always use **virtual destructors in base classes** if those classes are expected to be inherited and if derived objects will be deleted through base class pointers. This will save you from many memory leak issues and unexpected behaviors\!_

---
